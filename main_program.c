#pragma config(Sensor, in1,    LCollectorIR,   sensorAnalog)
#pragma config(Sensor, in2,    RCollectorIR,   sensorAnalog)
#pragma config(Sensor, in3,    FEnemyIR,       sensorAnalog)
#pragma config(Sensor, in4,    BEnemyIR,       sensorAnalog)
#pragma config(Sensor, in5,    LSDeli,         sensorAnalog)
#pragma config(Sensor, in6,    LSBack,         sensorAnalog)
#pragma config(Sensor, in7,    LSLeft,         sensorAnalog)
#pragma config(Sensor, in8,    LSRight,        sensorAnalog)
#pragma config(Sensor, dgtl1,  LEncode,        sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  REncode,        sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  FLLine,         sensorDigitalIn)
#pragma config(Sensor, dgtl6,  FRLine,         sensorDigitalIn)
#pragma config(Sensor, dgtl7,  BLLine,         sensorDigitalIn)
#pragma config(Sensor, dgtl8,  BRLine,         sensorDigitalIn)
#pragma config(Sensor, dgtl9,  West,           sensorDigitalIn)
#pragma config(Sensor, dgtl10, North,          sensorDigitalIn)
#pragma config(Sensor, dgtl11, East,           sensorDigitalIn)
#pragma config(Sensor, dgtl12, South,          sensorDigitalIn)
#pragma config(Motor,  port2,           Rmotor,        tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           Lmotor,        tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           Rollermotor,   tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           Delivermotor,  tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma DebuggerWindows("DebugStream")

// Global Variables to indicate current state
bool turning_direction;	// False->Left, True->Right
bool avoiding_edge = false;
bool collecting_ball = false;
bool ball_collected = false;
bool avoiding_enemy = false;
bool avoiding_wall = false;

// Pointers to the global variables that indicate current state
bool *p_turning_direction = &turning_direction;
bool *p_avoiding_edge = &avoiding_edge;
bool *p_collecting_ball = &collecting_ball;
bool *p_ball_collected = &ball_collected;
bool *p_avoiding_enemy = &avoiding_enemy;
bool *p_avoiding_wall = &avoiding_wall;

// Variables to ensure stable Line detection
const int LINE_FILTER_SIZE = 15;	// Number of samples for the filter
int FL_line_filter = 0;
int FR_line_filter = 0;
int BL_line_filter = 0;
int BR_line_filter = 0;
int line_sensor_triggered = 0;

// Pointers for Line filter variables
int *p_FL_line_filter = &FL_line_filter;
int *p_FR_line_filter = &FR_line_filter;
int *p_BL_line_filter = &BL_line_filter;
int *p_BR_line_filter = &BR_line_filter;
int *p_line_sensor_triggered = &line_sensor_triggered;

// Variables for Collector
const int LEFT_COLLECTOR_THRESHOLD = 700;
const int RIGHT_COLLECTOR_THRESHOLD = 800;
const int COLLECTOR_FILTER_SIZE = 10;
int left_collector_filter = 0;
int right_collector_filter = 0;

// Pointers for Collector variables
int *p_left_collector_filter = &left_collector_filter;
int *p_right_collector_filter = &right_collector_filter;

// Variables for Enemy Detection
const int FRONT_ENEMY_THRESHOLD = 600;
const int BACK_ENEMY_THRESHOLD = 1000;
const int FRONT_ENEMY_FILTER_SIZE = 45;
const int BACK_ENEMY_FILTER_SIZE = 20;
int front_enemy_filter = 0;
int back_enemy_filter = 0;

// Pointers for Enemy Detection variables
int *p_front_enemy_filter = &front_enemy_filter;
int *p_back_enemy_filter = &back_enemy_filter;

// Variables for Wall Detection
const int WALL_FILTER_SIZE = 30;

// Function Prototypes
void initialisation();
void move(int direction);
void align_to_compass ();
void reverseAndTurnLeft();
void reverseAndTurnRight();

// Task Prototypes
task searchPattern();							// Search pattern task
task lineFilter();								// Filter for line IR sensors
task collectorFilter();						// Filter for Left and Right Collector IR sensor
task enemyFilter();								// Filter for Front and Back enemy IR sensor
task collection_limit_switch();		// Polling limit switch triggering
task edgeDetection();							// Polling conditions for line detection
task wallDetection();							// Polling conditions for both Left and Right Collector IR sensor triggering
task front_enemy_avoid();					// Polling conditions for Front enemy IR sensor triggering
task back_enemy_avoid();					// Polling conditions for Back enemy IR sensor triggering
task delivery();
task returnToBase();
task edgeAvoidance();
task leftBallCollection();
task rightBallCollection();



/*
-------------Usage Status on built-in timers-------------
T1 -> used in function for delay without giving up timeslice
T2 -> used in ball collection panning
T3 -> unused
T4 -> unused
*/


//----------------INITIALISATION----------------
void initialisation()
{
	// Initialise sensor starting values
	motor[Rollermotor] = 0;	// Stop the collector roller
	SensorValue[LCollectorIR] = 0;
	SensorValue[RCollectorIR] = 0;
	SensorValue[FLLine] = 1;
	SensorValue[FRLine] = 1;
	SensorValue[BLLine] = 1;
	SensorValue[BRLine] = 1;
	SensorValue[LSDeli] = 1;

	// Move forward at the start of the round and move Delivery latch into position
	motor[Lmotor] = -90;	// Move forward at high speed
	motor[Rmotor] = 127;
	motor[Delivermotor] = 100;	// Raise the delivery latch
	sleep(500);									// Move forward a bit before starting Line Detection
	motor[Rollermotor] = -127;	// Start the collector roller
	startTask(lineFilter);			// Start required task for Line Detection
	startTask(edgeDetection);
	sleep(1500);								// Remaining duration to move forward
	motor[Delivermotor] = 0;		// Stop moving delivery latch
	move(0);										// Stop moving

}


//--------------------MOTOR CONTROLS--------------------
// Function for movement control
void move(int direction)
{
	int turning_speed = 40;
	/*
	LEGEND
	0: stop
	1: forward
	2: backward
	3: turn left
	4: turn right
	*/
	switch(direction)
	{
		case 0:	// Stop
			motor[Lmotor] = 0;
			motor[Rmotor] = 0;
			break;
		case 1:	// Forward
			motor[Lmotor] = -35;
			motor[Rmotor] = 40;
			break;
		case 2:	// Reverse
			motor[Lmotor] = 35;
			motor[Rmotor] = -40;
			break;
		case 3:	// Turn Left
			*p_turning_direction = false;
			motor[Lmotor] = turning_speed;
			motor[Rmotor] = turning_speed;
			break;
		case 4:	// Turn Right
			*p_turning_direction = true;
			motor[Lmotor] = -turning_speed;
			motor[Rmotor] = -turning_speed;
			break;
		default:
			break;
	}
}


//--------------------------SEARCH PATTERN--------------------------
// Function to perform the Search Pattern
task searchPattern()
{
	while(true)
	{
		motor[Rollermotor] = -127;	// Ensure Roller motor start
		for (int i=0; i<3; i++)
		{
			move(3);	// Turn left
			sleep(1500);
			move(0);	// Stop moving
			sleep(20);
			move(4);	// Turn right
			sleep(3200);
			move(0);	// Stop moving
			sleep(20);
			move(3);	// Turn back left again
			sleep(1000);
			move(0);	// Stop moving
			sleep(20);
			move(1);	// Forward
			sleep(1500);
			move(0);	// Stop moving
			sleep(20);
		}
		align_to_compass();				// Face south (might hog CPU usage)
		motor[Rollermotor] = 100;	// Reverse for a short while
		move(1);									// Forward
		sleep(1000);							// Duration to move forward
	}
}


//---------------------------EDGE DETECTION------------------------------
// Edge Avoidance sequence (Highest Priority task)
task edgeAvoidance()
{
	// Stop required tasks
	stopTask(searchPattern);
	stopTask(front_enemy_avoid);
	stopTask(wallDetection);
	stopTask(leftBallCollection);
	stopTask(rightBallCollection);

	// Variables for
	static int prev_avoidance = 0;
	static int counter = 0;

	// Check if same avoidance is performed in a row
	if (*p_line_sensor_triggered == prev_avoidance)
	{
		counter++;
	}
	else
	{
		counter = 0;
	}

	// If same avoidance occur 4 times in a row
	if (counter >= 2)
	{
		// If Front line sensor triggered
		if (*p_line_sensor_triggered == 1 || *p_line_sensor_triggered == 2)
		{
			*p_line_sensor_triggered = 5;
		}
		// If Back line sensor triggered
		else if (*p_line_sensor_triggered == 3 || *p_line_sensor_triggered == 4)
		{
			*p_line_sensor_triggered = 6;
		}

		counter = 0;	// reset counter
	}

	/*
	Sensor Legend
	1: Front Left sensor
	2: Front Right sensor
	3: Back Left sensor
	4: Back Right sensor
	*/
	int duration = 1500;	// Turning duration
	switch(*p_line_sensor_triggered)
	{
		case 1:	// Front Left sensor
			move(2);	// reverse
			sleep(500);
			move(4);	// turn right
			sleep(duration);
			break;
		case 2:	// Front Right sensor
			move(2);	// reverse
			sleep(500);
			move(3);	// turn left
			sleep(duration);
			break;
		case 3:	// Back Left sensor
			move(1);	// move forward
			sleep(500);
			move(3);	// turn left
			sleep(duration);
			break;
		case 4:	// Back Right sensor
			move(1);	// move forward
			sleep(500);
			move(4);	// turn right
			sleep(duration);
			break;
		case 5:
			move(2);							// Reverse
			sleep(800);
			align_to_compass();		// Face South (Might hog CPU)
			move(1);							// Forward
			sleep(300);
		case 6:
			move(1);							// Forward
			sleep(800);
			align_to_compass();		// Face South (Might hog CPU)
			move(1);							// Forward
			sleep(300);
		default:
			break;
	}
	prev_avoidance = *p_line_sensor_triggered;
	move(0);	// stop moving
	sleep(200);

	// Restart required tasks
	startTask(searchPattern);
	startTask(wallDetection);
	startTask(front_enemy_avoid);

	// Update status
	*p_collecting_ball = false;	// Indicate stoppage of ball collection sequence
	*p_avoiding_enemy = false;	// Indicate end of enemy avoidance
	*p_avoiding_edge = false;		// Indicate end of edge avoidance
}

// Edge detection polling
task edgeDetection()
{
	while(true)
	{
		if (*p_FL_line_filter >= LINE_FILTER_SIZE)	// Front Left
		{
			*p_avoiding_edge = true;
			*p_line_sensor_triggered = 1;
			startTask(edgeAvoidance, kHighPriority);
		}
		else if (*p_FR_line_filter >= LINE_FILTER_SIZE)	// Front Right
		{
			*p_avoiding_edge = true;
			*p_line_sensor_triggered = 2;
			startTask(edgeAvoidance, kHighPriority);
		}
		else if (*p_BL_line_filter >= LINE_FILTER_SIZE)	// Back Left
		{
			*p_avoiding_edge = true;
			*p_line_sensor_triggered = 3;
			startTask(edgeAvoidance, kHighPriority);
		}
		else if (*p_BR_line_filter >= LINE_FILTER_SIZE)	// Back Right
		{
			*p_avoiding_edge = true;
			*p_line_sensor_triggered = 4;
			startTask(edgeAvoidance, kHighPriority);
		}
		sleep(1);	// To avoid CPU hogging
	}
}

// Filter for Line IR sensors
task lineFilter()
{
	while(true)
	{
		// Front Left
		if (SensorValue[FLLine] == 0) {*p_FL_line_filter += 1;}
		else {*p_FL_line_filter = 0;}

		// Front Right
		if (SensorValue[FRLine] == 0) {*p_FR_line_filter += 1;}
		else {*p_FR_line_filter = 0;}

		// Back Left
		if (SensorValue[BLLine] == 0) {*p_BL_line_filter += 1;}
		else {*p_BL_line_filter = 0;}

		// Back Right
		if (SensorValue[BRLine] == 0) {*p_BR_line_filter += 1;}
		else {*p_BR_line_filter = 0;}

		sleep(1);	// To avoid CPU hogging
	}
}


//------------------------BALL COLLECTION----------------------------
// Ball collection task if turning Left previously
task leftBallCollection()
{
	move(4);	// Turn Right (To compensate for overshoot)
	sleep(300);
	move(1);	// Forward
	sleep(3000);
	*p_collecting_ball = false;
}

// Ball collection task if turning Right previously
task rightBallCollection()
{
	move(3);	// Turn Left (To compensate for overshoot)
	sleep(300);
	move(1);	// Forward
	sleep(3000);
	*p_collecting_ball = false;
}

// Filter for Left and Right Collection IR sensors
task collectorFilter()
{
	while(true)
	{
		// Left Collection IR Sensor
		if (SensorValue[LCollectorIR] > LEFT_COLLECTOR_THRESHOLD && SensorValue[LCollectorIR] < 2500){*p_left_collector_filter += 1;}
		else{*p_left_collector_filter = 0;}

		// Right Collection IR Sensor
		if (SensorValue[RCollectorIR] > RIGHT_COLLECTOR_THRESHOLD && SensorValue[RCollectorIR] < 2500){*p_right_collector_filter += 1;}
		else{*p_right_collector_filter = 0;}

		sleep(1);	// To avoid CPU hogging
	}
}

// Collection limit switch polling
task collection_limit_switch()
{
	while(true)
	{
		// Check if ball hits limit switch
		if (SensorValue[LSDeli] == 0)
		{
			*p_collecting_ball = false;	// Indicate end of ball collection
			*p_ball_collected = true;		// Indicate ball was been collected
		}
		sleep(1);	// To avoid CPU hogging
	}
}


//--------------------ENEMY AVOIDANCE--------------------
// Task for enemy avoidance
task front_enemy_avoid() {
  while (true) {
    if (*p_front_enemy_filter >= FRONT_ENEMY_FILTER_SIZE && *p_avoiding_edge == false) // Front IR detects enemy
    {
			// Stop required tasks
			stopTask(searchPattern);
			stopTask(wallDetection);
			stopTask(leftBallCollection);
			stopTask(rightBallCollection);

    	*p_avoiding_enemy = true;			// Indicate start of enemy avoidance

      // Decide to turn left or right based on the robot's position
      if (SensorValue[East] == 0)  				// If robot is facing West
      {
        reverseAndTurnRight(); 							// Prefer to turn right
      }
      else if (SensorValue[West] == 0)  		// If robot is facing South
      {
        reverseAndTurnLeft(); 							// Prefer to turn left
      }
      else
      {
        // If the robot's orientation is not clear, choose a default direction
        move(2);	// Reverse
        align_to_compass();
      }

			// Update status
      *p_collecting_ball = false;		// Indicate end of ball collection
			*p_avoiding_enemy = false;	// Indicate end of enemy avoidance
			*p_avoiding_wall = false;

			// Restart required task
			startTask(searchPattern);
			startTask(wallDetection);
    }
    // Insert a small delay to prevent CPU hogging
    sleep(1);
  }
}

// Task for enemy avoidance when delivering the ball
task back_enemy_avoid()
{
	bool last_side_detected = false;	// left side: false, right side: true
	while(true)
	{
		if(*p_back_enemy_filter >= BACK_ENEMY_FILTER_SIZE && *p_avoiding_edge == false)
		{
			// Update status
			*p_avoiding_enemy = true;	// Indicate start of enemy avoidance

			//Stop required tasks
			stopTask(returnToBase);
			stopTask(delivery);

			// Restart required tasks
			startTask(lineFilter);
			startTask(edgeDetection);
			startTask(front_enemy_avoid);

			// Enemy Avoidance sequence
			move(1);		// Move forward
			sleep(500);
			// If previously avoided left edge
			if (last_side_detected == false)
			{
				move(4);	// Turn right
				sleep(500);
				last_side_detected = true;
			}
			// If previously avoided right edge
			else if (last_side_detected == true)
			{
				move(3);	// Turn left
				sleep(500);
				last_side_detected = false;
			}
			move(2);		// Reverse
			sleep(1000);

			// Update status
			*p_avoiding_enemy = false;	// Indicate end of enemy avoidance

			// Stop required tasks
			stopTask(lineFilter);
			stopTask(edgeDetection);
			stopTask(front_enemy_avoid);

			// Restart required tasks
			startTask(returnToBase);
			startTask(delivery);
		}
		sleep(1);	// To avoid CPU hogging
	}
}

// Function to reverse and turn left
void reverseAndTurnLeft() {
  move(2);           // Set motors to reverse
  sleep(800);       // Reverse duration
  move(3);           // Set motors to turn left
  sleep(300);        // Turning duration
  move(0);           // Stop moving
}

// Function to reverse and turn right
void reverseAndTurnRight() {
  move(2);           // Set motors to reverse
  sleep(800);       	// Reverse duration
  move(4);           // Set motors to turn right
  sleep(300);        // Reverse duration
  move(0);           // Stop moving
}

// Task for enemy filter
task enemyFilter()
{
	while(true)
	{
		// Front enemy IR sensor filter
		if (SensorValue[FEnemyIR] > FRONT_ENEMY_THRESHOLD && SensorValue[FEnemyIR] < 1200){*p_front_enemy_filter += 1;}
		else{*p_front_enemy_filter = 0;}

		// Front enemy IR sensor filter
		if (SensorValue[BEnemyIR] > BACK_ENEMY_THRESHOLD && SensorValue[BEnemyIR] < 2200){*p_back_enemy_filter += 1;}
		else{*p_back_enemy_filter = 0;}

		sleep(1);	// To avoid CPU hogging
	}
}


//-------------------------DELIVERY-------------------------
// Task to return back to the delivery area
task returnToBase()
{
	// loop until both back line sensors triggered
	while(true)
	{
		align_to_compass();	// face south
		// Reverse
		motor[Lmotor] = 40;
		motor[Rmotor] = -45;
		// If Back Left sensor triggered
		if(SensorValue[BLLine] == 0)
		{
			motor[Rollermotor] = 0;
			motor[Lmotor] = 35;
			motor[Rmotor] = 40;
			sleep(100);
		}
		// If Back Right sensor trigger
		if(SensorValue[BRLine] == 0)
		{
			motor[Rollermotor] = 0;
			motor[Lmotor] = -35;
			motor[Rmotor] = -40;
			sleep(100);
		}
		sleep(1);
	}
}

//Delivery condition polling
task delivery()
{
	while(true)
	{
		// If both back line sensors trigger
		if(SensorValue[BLLine] == 0 && SensorValue[BRLine] == 0)
		{
			motor[Rollermotor] = 0;			// Stop the roller
			stopTask(returnToBase);			// Stop Return To Base task
			stopTask(back_enemy_avoid);
			hogCPU();		// Hog CPU during the final Delivery sequence
			// Reverse
			motor[Lmotor] = 30;
			motor[Rmotor] = -35;
			sleep(100);
			// Lower the delivery latch
			motor[Delivermotor] = -100;
			sleep(1000);
			motor[Delivermotor] = 0;
			// Stop moving
			motor[Lmotor] = 0;
			motor[Rmotor] = 0;
			*p_ball_collected = false;
			releaseCPU();		// release CPU when ball successfully delivered
			break;
		}
		sleep(1);
	}
}

// Function to re-align robot to face South (Does not use sleep, will hog CPU a bit)
void align_to_compass ()
{
	if (SensorValue[West] == 0)	// If facing West
	{
		while(true)
		{
			motor[Rmotor] = 60; // Turn Left until facing South
			motor[Lmotor] = 60;
			// Once facing South (Not including South-West)
			if (SensorValue[West] == 1 && SensorValue[South] == 0)
			{
				motor[Lmotor] = 0;
				motor[Rmotor] = 0;
				break;		// End function
			}
		}
	}
	if (SensorValue[East] == 0) // If facing East
	{
		while (true)
		{
			motor[Lmotor] = -70; // Turn Right until facing South
			motor[Rmotor] = -70;
			// Once facing South (Not including South-East)
			if (SensorValue[South] == 0 && SensorValue[East]==1)
			{
				motor[Lmotor] = 0;
				motor[Rmotor] = 0;
				break;			// End function
			}
		}
	}
}


//-------------------WALL DETECTION-------------------
task wallDetection()
{
	while (true)
	{
		if (*p_right_collector_filter >= WALL_FILTER_SIZE && *p_left_collector_filter >= WALL_FILTER_SIZE && *p_avoiding_enemy == false && *p_avoiding_edge == false)
		{
			// Stop required tasks
			stopTask(searchPattern);
			stopTask(leftBallCollection);
			stopTask(rightBallCollection);

			// Update status
			*p_avoiding_wall = true;

			move(2);	// Reverse
			sleep(1000);
			align_to_compass();	// Turn to face South
			move(1);						// Move forward at the start of the round
			sleep(3000);				// Duration to move forward at the beginning
			move(0);						// Stop moving

			// Update status
			*p_avoiding_wall = false;
			*p_collecting_ball = false;

			// Restart required tasks
			startTask(searchPattern);
		}
		sleep(1);
	}
}


//-------------------------MAIN FUNCTION-------------------------
task main()
{
	//-------------Initialisation-------------
	initialisation();

	//-------------Start required tasks-------------
	startTask(collectorFilter);						// Task to start filter for Collector IR
	startTask(lineFilter);               	// Task to start filter for Line Sensors
	startTask(edgeDetection);            	// Task to check detection of edge after filter
	startTask(collection_limit_switch);   // Task to continuously poll collection limit switch
	startTask(enemyFilter);								// Task to start filter for Enemy IR sensor
	startTask(front_enemy_avoid);        // Task to check enemy detection
	startTask(searchPattern);             // Search pattern task
	startTask(wallDetection);							// Start wall detection task

	//-----------------MAIN LOOP-----------------
	while(true)
	{
		//----------------BALL COLLECTION------------------
		// Right Collector IR sensor triggered and Turning Left previously
		if (*p_avoiding_edge == false && *p_avoiding_enemy == false && *p_avoiding_wall == false && *p_ball_collected == false && *p_collecting_ball == false && *p_turning_direction == false && *p_right_collector_filter >= COLLECTOR_FILTER_SIZE)
		{
			*p_collecting_ball = true;	// change state to indicate collecting ball in progress
			stopTask(searchPattern);
			startTask(leftBallCollection);
		}
		// Left Collector IR sensor triggered and Turning Right previously
		if (*p_avoiding_edge == false && *p_avoiding_enemy == false && *p_avoiding_wall == false && *p_ball_collected == false && *p_collecting_ball == false && *p_turning_direction == true && *p_left_collector_filter >= COLLECTOR_FILTER_SIZE)
		{
			*p_collecting_ball = true;	// change state to indicate collecting ball in progress
			stopTask(searchPattern);
			startTask(rightBallCollection);
		}

		//---------------------BALL DELIVERY---------------------
		if (*p_ball_collected == true)
		{
			move(0);	// Stop Moving
			motor[Rollermotor] = 127;	// Reverse the Roller to remove extra ball

			// Stop required tasks
			stopTask(lineFilter);
			stopTask(edgeDetection);
			stopTask(front_enemy_avoid);
			stopTask(collectorFilter);
			stopTask(wallDetection);
			stopTask(collection_limit_switch);

			// Start required tasks
			startTask(back_enemy_avoid);
			startTask(returnToBase);
			startTask(delivery);

			// Keep main loop here during delivery sequence
			while(*p_ball_collected == true)
			{
				sleep(1);
			}

			// Stop required tasks
			stopTask(returnToBase);
			stopTask(delivery);
			stopTask(back_enemy_avoid);

			// Initialisation
			initialisation();

			// Restart required tasks
			startTask(lineFilter);
			startTask(edgeDetection);
			startTask(front_enemy_avoid);
			startTask(collectorFilter);
			startTask(wallDetection);
			startTask(collection_limit_switch);
			startTask(searchPattern);
		}
		sleep(1);
	}
}
